{"cells":[{"cell_type":"code","source":"---\ntitle: \"Mining of NYC Airbnb data\"\nauthor: \"Josip Domazet, student at Faculty of Electrical Engineering and Computing, Zagreb (Croatia)\"\ndate: '02 09 2019'\noutput: \n    html_document:\n        toc: true\n        theme: cosmo\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n<center><img src=\"https://images.pexels.com/photos/466685/pexels-photo-466685.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940\"></center>\n\n\n\n# About The Kernel\nThis kernel focuses on exploratory data analysis, but \nalso includes two regression models with _price_ as target variable. <br>\nI've focused more on visualisation in this kernel.  <br>\nEnjoy! :)\n\n\n# Loading Packages & Data\n\n```{r message=FALSE}\nlibrary(tidyverse)\nlibrary(ggthemes)\nlibrary(GGally)\nlibrary(ggExtra)\nlibrary(caret)\nlibrary(glmnet)\nlibrary(corrplot)\nlibrary(leaflet)\nlibrary(kableExtra)\nlibrary(RColorBrewer)\nlibrary(plotly)\nth <- theme_fivethirtyeight() + theme(axis.title = element_text(), axis.title.x = element_text()) # global theme for ggplot2 objects\nset.seed(252)\nairbnb <- read.csv(\"../input/new-york-city-airbnb-open-data/AB_NYC_2019.csv\", \n                   encoding=\"UTF-8\", stringsAsFactors = F, na.strings = c(\"\"))\n```\n\n\n# Data exploration\n\n## Structure and features\n\n```{r}\nhead(airbnb) %>% kable() %>% kable_styling()\n```\n\n\n```{r}\nsummary(airbnb)\n```\n\n\nFollowing columns can be ommited since they don't carry any useful information and hence wont' be used in predictive models:\n\n* _id_\n* _host_id_.\n\n```{r}\nnames_to_delete <- c(\"id\", \"host_id\")\nairbnb[names_to_delete] <- NULL\n```\n\nSince I used _stringsAsFactors = F_ in read.csv function,\nI have to transform following character columns to factor columns:\n\n* _host_name_\n* _neighbourhood_group_\n* _neighbourhood_\n* _room_type_\n\n```{r}\nnames_to_factor <- c(\"host_name\", \"neighbourhood_group\", \"neighbourhood\", \"room_type\")\nairbnb[names_to_factor] <- map(airbnb[names_to_factor], as.factor)\n\n```\nColumn _ last_review_ has to be converted to _airbnbe_ type using function _ymd_ from lubridate package.\n\n\n```{r}\nairbnb[c(\"last_review\")] <- airbnb[c(\"last_review\")] %>% map(~lubridate::ymd(.x))\n```\n\nSanity check:\n\n```{r}\nglimpse(airbnb)\n```\n\nEverything looks alright now!\n\n## Missing data\n\n```{r}\nmissing_airbnb <- airbnb %>% summarise_all(~(sum(is.na(.))/n()))\nmissing_airbnb <- gather(missing_airbnb, key = \"variables\", value = \"percent_missing\")\nmissing_airbnb <- missing_airbnb[missing_airbnb$percent_missing > 0.0, ] \nggplot(missing_airbnb, aes(x = reorder(variables, percent_missing), y = percent_missing)) +\ngeom_bar(stat = \"identity\", fill = \"red\", aes(color = I('white')), size = 0.3)+\nxlab('variables')+\ncoord_flip() + \nth  +\n  ggtitle(\"Missing Data\") +\n  xlab(\"Column name\") +\n  ylab(\"Percentage missing\") +\n  annotate(\"text\", x = 1.5, y = 0.1,label = \"host_name and name have less than 0.001\\n percentage missing\", color = \"slateblue\", size = 5)\n```\n\nColumns _reviews_per_month_ and _last_review_ have exactly the same value of \npercentage missing (~ 20.56 %). That makes sense because if you don't know when \nthe last review was, you can't calculate reviews per month :)\n\n# Data Visualisation\n\n## Price \nThe most important (target) variable is _price_.\n\n\n### Histogram & Density \n```{r}\nggplot(airbnb, aes(price)) +\n  geom_histogram(bins = 30, aes(y = ..density..), fill = \"purple\") + \n  geom_density(alpha = 0.2, fill = \"purple\") +\n  th +\n  ggtitle(\"Distribution of price\",\n          subtitle = \"The distribution is very skewed\") +\n  theme(axis.title = element_text(), axis.title.x = element_text()) +\n  geom_vline(xintercept = round(mean(airbnb$price), 2), size = 2, linetype = 3)\n```\n\n### Histogram & Density with log10 transformation\n\nSince the original distribution is very skewed, logarithmic transformation can be used to gain\nbetter insight into data.\n\n```{r message=F, warning=F}\nggplot(airbnb, aes(price)) +\n  geom_histogram(bins = 30, aes(y = ..density..), fill = \"purple\") + \n  geom_density(alpha = 0.2, fill = \"purple\") +\n  th +\n  ggtitle(\"Transformed distribution of price\",\n          subtitle = expression(\"With\" ~'log'[10] ~ \"transformation of x-axis\")) +\n  #theme(axis.title = element_text(), axis.title.x = element_text()) +\n  geom_vline(xintercept = round(mean(airbnb$price), 2), size = 2, linetype = 3) +\n  scale_x_log10() +\n  annotate(\"text\", x = 1800, y = 0.75,label = paste(\"Mean price = \", paste0(round(mean(airbnb$price), 2), \"$\")),\n           color = \t\"#32CD32\", size = 8)\n```\n\n### Histogram & Density with log10 transformation for neighbourhood areas\n\n\nNew York City consist of five neighbourhood areas:\n\n1. Manhattan\n2. Brooklyn\n3. Queens\n4. The Bronx\n5. Staten Island.\n\nIt can be useful to vizualise the distribution of price for every neighbourhood area.\n\n```{r warning=F, error=F}\n\nairbnb_nh <- airbnb %>%\n  group_by(neighbourhood_group) %>%\n  summarise(price = round(mean(price), 2))\n\n\nggplot(airbnb, aes(price)) +\n  geom_histogram(bins = 30, aes(y = ..density..), fill = \"purple\") + \n  geom_density(alpha = 0.2, fill = \"purple\") +\n  th +\n  ggtitle(\"Transformed distribution of price\\n by neighbourhood groups\",\n          subtitle = expression(\"With\" ~'log'[10] ~ \"transformation of x-axis\")) +\n  geom_vline(data = airbnb_nh, aes(xintercept = price), size = 2, linetype = 3) +\n  geom_text(data = airbnb_nh,y = 1.5, aes(x = price + 1400, label = paste(\"Mean  = \",price)), color = \"darkgreen\", size = 4) +\n  facet_wrap(~neighbourhood_group) +\n  scale_x_log10() \n```\n\n### Above Average Price Objects by Neighourhood Areas\n\n```{r}\nairbnb %>% filter(price >= mean(price)) %>% group_by(neighbourhood_group, room_type) %>% tally %>% \n  ggplot(aes(reorder(neighbourhood_group,desc(n)), n, fill = room_type)) +\n  th +\n  xlab(NULL) +\n  ylab(\"Number of objects\") +\n  ggtitle(\"Number of above average price objects\",\n          subtitle = \"Most of them are entire homes or apartments\") +\n           geom_bar(stat = \"identity\")\n```\n\n### Boxplot of price by room type\n\nWe can also investigate price by room type:\n\n* Entire home or apartment\n* Private Room\n* Shared Room\n\n```{r warning=F}\nggplot(airbnb, aes(x = room_type, y = price)) +\n  geom_boxplot(aes(fill = room_type)) + scale_y_log10() +\n  th + \n  xlab(\"Room type\") + \n  ylab(\"Price\") +\n  ggtitle(\"Boxplots of price by room type\",\n          subtitle = \"Entire homes and apartments have the highest avg price\") +\n  geom_hline(yintercept = mean(airbnb$price), color = \"purple\", linetype = 2)\n```\n\nAs expected, entire home or aparment type has the highest average price.\nIt was also expected that shared rooms would have lower price than private rooms.\n\n### Summary of price distributions\n```{r}\nairbnb %>% arrange(desc(price)) %>% top_n(10) %>% select(- host_name, -name) %>%  \n  ggplot(aes(x = price, fill = neighbourhood_group)) +\n  geom_histogram(bins = 50) +\n  scale_x_log10() + \n  ggtitle(\"Summary of price distributions\") +\n  facet_wrap(~room_type + neighbourhood_group)\n```\n\n### Price & Availability \n\n\n```{r warning=F}\nggplot(airbnb, aes(availability_365, price)) +\n  th +\n  geom_point(alpha = 0.2, color = \"slateblue\") +\n  geom_density(stat = \"identity\", alpha = 0.2) +\n  xlab(\"Availability during year\") +\n  ylab(\"Price\") +\n  ggtitle(\"Relationship between availability\",\n          subtitle = \"there is not clear relationship\") \n```\n\nIt's hard to see clear pattern,\nbut there's a lot of expensive objects \nwith few available days and many available days.\n\n### Price & Number Of Reviews\n```{r}\nggplot(airbnb, aes(number_of_reviews, price)) +\n  th + theme(axis.title = element_text(), axis.title.x = element_text()) +\n  geom_point(aes(size = price), alpha = 0.05, color = \"slateblue\") +\n  xlab(\"Number of reviews\") +\n  ylab(\"Price\") +\n  ggtitle(\"Relationship between number of reviews\",\n          subtitle = \"The most expensive objects have small number of reviews (or 0)\")\n```\n\n## Number of objects by neighbourhood areas\n\n```{r}\nairbnb %>% group_by(neighbourhood_group) %>% tally() %>% \n  ggplot(aes(x = reorder(neighbourhood_group, n), n)) +\n  geom_bar(stat = \"identity\", fill = \"purple\") +\n  theme_fivethirtyeight() +\n  ggtitle(\"Number of objects by neighbourhood group\") +\n  geom_text(aes(x = neighbourhood_group, y = 1, label = paste0(n),\n                colour = ifelse(neighbourhood_group %in%\n                                                              c(\"Manhattan\", \"Brooklyn\", \n                                                                \"Queens\"), '1', '2')),\n            hjust=-1.5, vjust=.5, size = 4, \n            fontface = 'bold') +\n  coord_flip() +\n  scale_color_manual(values=c(\"white\",\"black\"), guide = F)\n```\n\n### Leaflet map\n\n```{r}\n pal <- colorFactor(palette = c(\"red\", \"green\", \"blue\", \"purple\", \"yellow\"), domain = airbnb$neighbourhood_group)\n \n leaflet(data = airbnb) %>% addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%  addCircleMarkers(~longitude, ~latitude, color = ~pal(neighbourhood_group), weight = 1, radius=1, fillOpacity = 0.1, opacity = 0.1,\n                                                                                                        label = paste(\"Name:\", airbnb$name)) %>% \n     addLegend(\"bottomright\", pal = pal, values = ~neighbourhood_group,\n     title = \"Neighbourhood groups\",\n     opacity = 1\n   )\n```\n\nManhattan has the highest number of objects while it's the smallest neighbourhood group by area.\nThat can be explained by the fact that it's the most popular neighbourhood group with biggest GDP.\n\n## Correlation Matrix\n\nSpearman correlation will be used since \nI not interested particularly in linear relationships.\n\n```{r}\nairbnb_cor <- airbnb[, sapply(airbnb, is.numeric)]\nairbnb_cor <- airbnb_cor[complete.cases(airbnb_cor), ]\ncorrelation_matrix <- cor(airbnb_cor, method = \"spearman\")\ncorrplot(correlation_matrix, method = \"color\")\n```\n\n# Machine Learning\n\n## Data Splitting\n\nTraining set will be 70% percent of the original data.\nObjects with price equal to 0 will be ommited since\nprice can't be 0 (faulty records).\nThey would make predictive models significantly weaker.\n\n```{r}\nairbnb <- airbnb %>% mutate(id = row_number())\nairbnb_train <- airbnb %>% sample_frac(.7) %>% filter(price > 0)\nairbnb_test  <- anti_join(airbnb, airbnb_train, by = 'id') %>% filter(price > 0)\n\n# sanity check\nnrow(airbnb_train) + nrow(airbnb_test) == nrow(airbnb %>% filter(price > 0))\n```\n\n## 1st Linear Regression model\n```{r}\n\nfirst_model <- train(price ~ latitude + longitude + room_type + minimum_nights  + availability_365 + neighbourhood_group, data = airbnb_train, method = \"lm\")\nsummary(first_model)\n\n```\n\nThis model is not so good.\nMedian residual error is -24.2, while it should be near 0.\n\\(  R^2 = 0.1 \\) is also not so good.\n\nLet's plot the first model.\n\n```{r}\nplot(first_model$finalModel)\n```\n\nNormal Q-Q plot clearly shows that first linear model **doesn't** satisfy\nlinear model assumptions (normal Q-Q plot should be straight line).\n\nSince the model seems bad, it will not be used in predicting new prices.\n\n## 2nd Linear Regression Model\n\nSecond model will introduce logarithmic transformations.\nAlso, training dataset will be filtered by price so outliers are removed.\n\n```{r}\nlearn <- airbnb_train %>% filter(price < quantile(airbnb_train$price, 0.9) & price > quantile(airbnb_train$price, 0.1)) %>% tidyr::drop_na()\nsecond_model <- lm(log(price) ~ room_type + neighbourhood_group + latitude + longitude \n                        + number_of_reviews + availability_365\n                       + reviews_per_month + \n                     calculated_host_listings_count + minimum_nights, data = learn)\n# Summarize the results\nsummary(second_model)\n```\n\nThis model is an improvement.\nMedian residual error is now -0.0145, which is far better than -25.5 from the first model.\n\\(  R^2 = 0.491 \\) means that this model explains about 50% variance of target variable.\n\n```{r}\nplot(second_model)\n```\n\nQ-Q plot for this model looks much better then for the previous one.\n\n\n### Predict prices for training set\n```{r}\nairbnb_test <- airbnb_test %>% filter(price <= quantile(airbnb_train$price, 0.9) & price >= quantile(airbnb_train$price, 0.1)) %>% tidyr::drop_na()\npred_regression <- predict(second_model, newdata = airbnb_test)\npred_regression <- exp(pred_regression)\n\nRMSE_regression <- sqrt(mean( (airbnb_test$price - pred_regression)**2 ))\n\nSSE <- sum((airbnb_test$price - pred_regression)**2)\nSSR <- sum((pred_regression - mean(airbnb_test$price)) ** 2)\nR2 <- 1 - SSE/(SSE + SSR)\n\n\nregression_results <- tibble(\n  obs = airbnb_test$price,\n  pred = pred_regression,\n  diff = pred - obs,\n  abs_diff = abs(pred - obs),\n  neighbourhood = airbnb_test$neighbourhood,\n  name = airbnb_test$name,\n  group = airbnb_test$neighbourhood_group,\n  type = airbnb_test$room_type\n  \n)\n\nregression_plot <- regression_results %>% \n  ggplot(aes(obs, pred)) +\ngeom_point(alpha = 0.1, aes(text = paste(\"Name:\", name, \"\\nGroup:\", group, \"\\nType:\", type,\n                                           \"\\nPrice diff = \", diff))) +\n  th +\n  scale_x_log10() +\n  scale_y_log10() +\n  ggtitle(\"Observed vs predicted\",\n          subtitle = \"Linear regression model\") + \n  geom_abline(slope = 1, intercept = 0, color = \"blue\", linetype = 2)  +\n  facet_wrap(~type)\n\nggplotly(regression_plot)\n\n```\n\nMetrics for testing set:\n\\( R^2 = 0.43 \\) and \n\\( RMSE = 41.24 \\).\n\nThis model could be improved by using _name_ variable and examining which keywords in _name_ indicate higher/lower prices. \n\n\nTHE END.\n\n","metadata":{"collapsed":false,"_kg_hide-input":false},"execution_count":0,"outputs":[]}],"metadata":{"language_info":{"name":"python","version":"3.6.6","mimetype":"text/x-python","codemirror_mode":{"name":"ipython","version":3},"pygments_lexer":"ipython3","nbconvert_exporter":"python","file_extension":".py"},"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"}},"nbformat":4,"nbformat_minor":4}